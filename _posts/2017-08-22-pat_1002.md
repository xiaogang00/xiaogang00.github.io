---
layout: post
title: pat甲级1002
category: pat
tags: pat cpp
---

* content
{:toc}

题目的链接网站：[https://www.patest.cn/contests/pat-a-practise/1002](https://www.patest.cn/contests/pat-a-practise/1002)





很简单的链表相加的题目，不过有几个点没有通过，不想改了。
如果有人看到发现问题，麻烦告诉我一下。

这题主要不是为了做题，是为了复习一下链表的实现。

题目代码如下：
```cpp
//
//  solution.cpp
//  pat
//
//  Created by pengsida on 2017/7/5.
//  Copyright © 2017年 pengsida. All rights reserved.
//

#include <iostream>
#include <string>

using namespace std;

struct list_node {
    int exponents;
    double coefficients;
    list_node* next;
    
    list_node() {
        exponents = 0;
        coefficients = 0;
        next = NULL;
    }
    
    list_node(int exp, double coe) {
        exponents = exp;
        coefficients = coe;
        next = NULL;
    }
    
    list_node(const list_node& other) {
        exponents = other.exponents;
        coefficients = other.coefficients;
        next = NULL;
    }
    
    list_node(const list_node* other) {
        exponents = other->exponents;
        coefficients = other->coefficients;
        next = NULL;
    }
};


class self_list {
private:
    list_node* head;
    int nr_nodes;
    
public:
    self_list(): head(new list_node(0, 0)), nr_nodes(0) {}
    
    ~self_list() {
        list_node* current = head;
        
        if (!current)
            return;
        
        list_node* temp = current->next;
        
        while (current) {
            temp = current->next;
            delete current;
            current = temp;
        }
    }
    
    void push_node_back(list_node* node) {
        list_node* temp = head->next;
        nr_nodes++;
        
        if (!temp) {
            head->next = node;
            return;
        }
        
        while (temp->next) {
            temp = temp->next;
        }
        
        temp->next = node;
    }
    
    void push_node_back(int exp, double coeff) {
        list_node* new_node = new list_node(exp, coeff);
        push_node_back(new_node);
    }
    
    self_list* operator+(const self_list& other_list) {
        list_node* current1 = head->next;
        list_node* current2 = other_list.head->next;
        self_list* list = new self_list;
        
        while (current1 && current2) {
            if (current1->exponents == current2->exponents) {
                if (current1->coefficients + current2->coefficients != 0)
                    list->push_node_back(current1->exponents, current1->coefficients + current2->coefficients);
                current1 = current1->next;
                current2 = current2->next;
            }
            else if (current1->exponents > current2->exponents) {
                list->push_node_back(current1->exponents, current1->coefficients);
                current1 = current1->next;
            }
            else {
                list->push_node_back(current2->exponents, current2->coefficients);
                current2 = current2->next;
            }
        }
        
        while (current1) {
            list->push_node_back(current1->exponents, current1->coefficients);
            current1 = current1->next;
        }
        
        while (current2) {
            list->push_node_back(current2->exponents, current2->coefficients);
            current2 = current2->next;
        }
        
        return list;
    }
    
    void print_list() {
        list_node* temp = head->next;
        
        cout << nr_nodes;
        while (temp) {
            cout << " " << temp->exponents << " " << temp->coefficients;
            temp = temp->next;
        }
        cout << endl;
    }
};


void parse_argument(self_list& list) {
    int nr_nodes;
    int exp = 0;
    double coef = 0;
    
    cin >> nr_nodes;
    for (int i = 0; i < nr_nodes; i++) {
        cin >> exp >> coef;
        list.push_node_back(exp, coef);
    }
}


int main() {
    self_list list1;
    self_list list2;
    self_list* list;
    
    parse_argument(list1);
    parse_argument(list2);
    list = list1 + list2;
    list->print_list();
    
    delete list;
    return 0;
}
```